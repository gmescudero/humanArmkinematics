/**
 * @file calib_two_axes_gn.c
 * @author German Moreno Escudero
 * @brief This file implements the requiered functions for two rotation axes calibration with Gauss-Newton method
 * @version 0.1
 * @date 2022-11-01
 * 
 * @copyright Copyright (c) 2022
 * 
 */
#include "calib.h"
#include "arm.h"
#include "vector3.h"
#include "constants.h"
#include "matrix.h"
#include <math.h>
#include <stdlib.h>



#define CAL_PARAMETERS_NUM (4)
#define CAL_TRYS_NUM (5)
#define CAL_ERROR_MIN_DIFF (1e-6)
#define CAL_ERROR_STALLED_COUTDOWN (15)

#define QUAT_ZERO_INIT {.w=1.0,.v={0.0,0.0,0.0}}

typedef struct CAL_DATA_STRUCT {
    bool initialized;
    MATRIX phi;
    int sph_alt1;
    int sph_alt2;
    double error;
    Quaternion q_sensor_to_body_arm;
    Quaternion q_sensor_to_body_forearm;

} CAL_DATA;

static CAL_DATA scal_data = {
    .initialized = false,
    .sph_alt1 = 0,
    .sph_alt2 = 0,
    .error = 1e300,
    .q_sensor_to_body_arm = QUAT_ZERO_INIT,
    .q_sensor_to_body_forearm = QUAT_ZERO_INIT
};

/**
 * @brief Error value calculated from rotation vectors of a single measure
 * 
 * @param j_x1 (input) X component of the first rotation vector
 * @param j_y1 (input) Y component of the first rotation vector
 * @param j_z1 (input) Z component of the first rotation vector
 * @param j_x2 (input) X component of the second rotation vector
 * @param j_y2 (input) Y component of the second rotation vector
 * @param j_z2 (input) Z component of the second rotation vector
 * @param omega_x (input) X component of the relative angular velocity
 * @param omega_y (input) Y component of the relative angular velocity
 * @param omega_z (input) Z component of the relative angular velocity
 * @return double 
 */
double scal_error_xyz(double j_x1, double j_y1,  double j_z1, double j_x2, double j_y2, double j_z2, double omega_x, double omega_y, double omega_z) {
    return (omega_x*(j_y1*j_z2 - j_y2*j_z1)/sqrt(pow(j_x1*j_y2 - j_x2*j_y1, 2) + pow(-j_x1*j_z2 + j_x2*j_z1, 2) + pow(j_y1*j_z2 - j_y2*j_z1, 2)) + omega_y*(-j_x1*j_z2 + j_x2*j_z1)/sqrt(pow(j_x1*j_y2 - j_x2*j_y1, 2) + pow(-j_x1*j_z2 + j_x2*j_z1, 2) + pow(j_y1*j_z2 - j_y2*j_z1, 2)) + omega_z*(j_x1*j_y2 - j_x2*j_y1)/sqrt(pow(j_x1*j_y2 - j_x2*j_y1, 2) + pow(-j_x1*j_z2 + j_x2*j_z1, 2) + pow(j_y1*j_z2 - j_y2*j_z1, 2)));
}
/**
 * @brief Error derivatives of each parameter for a single measure. Spherical 1 and 1
 * 
 * @note Code generated by sympy
 * 
 * @param omega_x (input) X component of the relative angular velocity
 * @param omega_y (input) Y component of the relative angular velocity
 * @param omega_z (input) Z component of the relative angular velocity
 * @param theta_1 (input) Theta angle of the spherical representation of the first rotation vector
 * @param rho_1 (input) Rho angle of the spherical representation of the first rotation vector
 * @param theta_2 (input) Theta angle of the spherical representation of the second rotation vector
 * @param rho_2 (input) Rho angle of the spherical representation of the second rotation vector
 * @param out_xxxxxxxxxxxxxxxxxxx (output) Derivatives of the error according to each angle: de/dth1, de/drh1, de/dth2, de/drh2
 */
static void scal_error_derivatives_11(double omega_x, double omega_y, double omega_z, double theta_1, double rho_1, double theta_2, double rho_2, double *out_xxxxxxxxxxxxxxxxxxx) {
   out_xxxxxxxxxxxxxxxxxxx[0] = ((1.0/32.0)*(-omega_x*(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1)) + omega_y*(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1)) + omega_z*sin(theta_1)*sin(theta_2)*sin(rho_1 - rho_2))*(4*sin(2*theta_1) + 6*sin(2*theta_1 - 2*theta_2) + 6*sin(2*theta_1 + 2*theta_2) - 2*sin(-2*rho_1 + 2*rho_2 + 2*theta_1) - 2*sin(2*rho_1 - 2*rho_2 + 2*theta_1) + sin(-2*rho_1 + 2*rho_2 + 2*theta_1 + 2*theta_2) - 4*sin(-rho_1 + rho_2 + 2*theta_1 + 2*theta_2) - 4*sin(rho_1 - rho_2 - 2*theta_1 + 2*theta_2) + 4*sin(rho_1 - rho_2 + 2*theta_1 - 2*theta_2) - 4*sin(rho_1 - rho_2 + 2*theta_1 + 2*theta_2) - sin(2*rho_1 - 2*rho_2 - 2*theta_1 + 2*theta_2) + sin(2*rho_1 - 2*rho_2 + 2*theta_1 - 2*theta_2) + sin(2*rho_1 - 2*rho_2 + 2*theta_1 + 2*theta_2)) + (omega_x*(sin(rho_1)*cos(theta_1)*cos(theta_2) + sin(rho_2)*sin(theta_1)*sin(theta_2)) - omega_y*(sin(theta_1)*sin(theta_2)*cos(rho_2) + cos(rho_1)*cos(theta_1)*cos(theta_2)) - omega_z*sin(theta_2)*sin(rho_1 - rho_2)*cos(theta_1))*(pow(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1), 2) + pow(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1), 2) + pow(sin(theta_1), 2)*pow(sin(theta_2), 2)*pow(sin(rho_1 - rho_2), 2)))/pow(pow(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1), 2) + pow(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1), 2) + pow(sin(theta_1), 2)*pow(sin(theta_2), 2)*pow(sin(rho_1 - rho_2), 2), 3.0/2.0);
   out_xxxxxxxxxxxxxxxxxxx[1] = ((sin(theta_1)*sin(theta_2)*cos(rho_1 - rho_2) + cos(theta_1)*cos(theta_2))*(-omega_x*(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1)) + omega_y*(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1)) + omega_z*sin(theta_1)*sin(theta_2)*sin(rho_1 - rho_2))*sin(theta_2)*sin(rho_1 - rho_2) + (omega_x*cos(rho_1)*cos(theta_2) + omega_y*sin(rho_1)*cos(theta_2) - omega_z*sin(theta_2)*cos(rho_1 - rho_2))*(pow(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1), 2) + pow(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1), 2) + pow(sin(theta_1), 2)*pow(sin(theta_2), 2)*pow(sin(rho_1 - rho_2), 2)))*sin(theta_1)/pow(pow(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1), 2) + pow(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1), 2) + pow(sin(theta_1), 2)*pow(sin(theta_2), 2)*pow(sin(rho_1 - rho_2), 2), 3.0/2.0);
   out_xxxxxxxxxxxxxxxxxxx[2] = ((-omega_x*(sin(rho_1)*sin(theta_1)*sin(theta_2) + sin(rho_2)*cos(theta_1)*cos(theta_2)) + omega_y*(sin(theta_1)*sin(theta_2)*cos(rho_1) + cos(rho_2)*cos(theta_1)*cos(theta_2)) - omega_z*sin(theta_1)*sin(rho_1 - rho_2)*cos(theta_2))*(pow(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1), 2) + pow(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1), 2) + pow(sin(theta_1), 2)*pow(sin(theta_2), 2)*pow(sin(rho_1 - rho_2), 2)) - 1.0/32.0*(-omega_x*(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1)) + omega_y*(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1)) + omega_z*sin(theta_1)*sin(theta_2)*sin(rho_1 - rho_2))*(-4*sin(2*theta_2) + 6*sin(2*theta_1 - 2*theta_2) - 6*sin(2*theta_1 + 2*theta_2) + 2*sin(-2*rho_1 + 2*rho_2 + 2*theta_2) + 2*sin(2*rho_1 - 2*rho_2 + 2*theta_2) - sin(-2*rho_1 + 2*rho_2 + 2*theta_1 + 2*theta_2) + 4*sin(-rho_1 + rho_2 + 2*theta_1 + 2*theta_2) - 4*sin(rho_1 - rho_2 - 2*theta_1 + 2*theta_2) + 4*sin(rho_1 - rho_2 + 2*theta_1 - 2*theta_2) + 4*sin(rho_1 - rho_2 + 2*theta_1 + 2*theta_2) - sin(2*rho_1 - 2*rho_2 - 2*theta_1 + 2*theta_2) + sin(2*rho_1 - 2*rho_2 + 2*theta_1 - 2*theta_2) - sin(2*rho_1 - 2*rho_2 + 2*theta_1 + 2*theta_2)))/pow(pow(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1), 2) + pow(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1), 2) + pow(sin(theta_1), 2)*pow(sin(theta_2), 2)*pow(sin(rho_1 - rho_2), 2), 3.0/2.0);
   out_xxxxxxxxxxxxxxxxxxx[3] = (-(sin(theta_1)*sin(theta_2)*cos(rho_1 - rho_2) + cos(theta_1)*cos(theta_2))*(-omega_x*(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1)) + omega_y*(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1)) + omega_z*sin(theta_1)*sin(theta_2)*sin(rho_1 - rho_2))*sin(theta_1)*sin(rho_1 - rho_2) + (-omega_x*cos(rho_2)*cos(theta_1) - omega_y*sin(rho_2)*cos(theta_1) + omega_z*sin(theta_1)*cos(rho_1 - rho_2))*(pow(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1), 2) + pow(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1), 2) + pow(sin(theta_1), 2)*pow(sin(theta_2), 2)*pow(sin(rho_1 - rho_2), 2)))*sin(theta_2)/pow(pow(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1), 2) + pow(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1), 2) + pow(sin(theta_1), 2)*pow(sin(theta_2), 2)*pow(sin(rho_1 - rho_2), 2), 3.0/2.0);
}
/**
 * @brief Error derivatives of each parameter for a single measure. Spherical 2 and 1
 * 
 * @note Code generated by sympy
 * 
 * @param omega_x (input) X component of the relative angular velocity
 * @param omega_y (input) Y component of the relative angular velocity
 * @param omega_z (input) Z component of the relative angular velocity
 * @param theta_1 (input) Theta angle of the spherical representation of the first rotation vector
 * @param rho_1 (input) Rho angle of the spherical representation of the first rotation vector
 * @param theta_2 (input) Theta angle of the spherical representation of the second rotation vector
 * @param rho_2 (input) Rho angle of the spherical representation of the second rotation vector
 * @param out_xxxxxxxxxxxxxxxxxxx (output) Derivatives of the error according to each angle: de/dth1, de/drh1, de/dth2, de/drh2
 */
static void scal_error_derivatives_21(double omega_x, double omega_y, double omega_z, double theta_1, double rho_1, double theta_2, double rho_2, double *out_xxxxxxxxxxxxxxxxxxx) {
   out_xxxxxxxxxxxxxxxxxxx[0] = ((pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*pow(sin(theta_2), 2) + pow(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2), 2))*(omega_x*(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1))*cos(theta_1) + omega_y*(sin(theta_1)*cos(theta_2) + sin(theta_2)*cos(rho_1)*cos(rho_2)*cos(theta_1)) - omega_z*(sin(rho_1)*cos(rho_2)*cos(theta_1) + sin(rho_2)*sin(theta_1))*sin(theta_2)) - (omega_x*(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1))*sin(theta_1) + omega_y*(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2)) - omega_z*(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1))*sin(theta_2))*(pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*sin(theta_1)*cos(theta_1) + (sin(theta_1)*cos(theta_2) + sin(theta_2)*cos(rho_1)*cos(rho_2)*cos(theta_1))*(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2)) + (sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1))*(sin(rho_1)*cos(rho_2)*cos(theta_1) + sin(rho_2)*sin(theta_1))*pow(sin(theta_2), 2)))/pow(pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*pow(sin(theta_2), 2) + pow(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2), 2), 3.0/2.0);
   out_xxxxxxxxxxxxxxxxxxx[1] = ((omega_x*(sin(rho_1)*sin(rho_2)*sin(theta_2) + cos(rho_1)*cos(theta_2)) - omega_y*sin(rho_1)*sin(theta_2)*cos(rho_2) - omega_z*sin(theta_2)*cos(rho_1)*cos(rho_2))*(pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*pow(sin(theta_2), 2) + pow(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2), 2)) - (omega_x*(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1))*sin(theta_1) + omega_y*(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2)) - omega_z*(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1))*sin(theta_2))*((sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1))*(sin(rho_1)*sin(rho_2)*sin(theta_2) + cos(rho_1)*cos(theta_2))*sin(theta_1) + (sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1))*pow(sin(theta_2), 2)*cos(rho_1)*cos(rho_2) - (sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2))*sin(rho_1)*sin(theta_2)*cos(rho_2)))*sin(theta_1)/pow(pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*pow(sin(theta_2), 2) + pow(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2), 2), 3.0/2.0);
   out_xxxxxxxxxxxxxxxxxxx[2] = ((pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*pow(sin(theta_2), 2) + pow(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2), 2))*(-omega_x*(sin(rho_1)*sin(theta_2) + sin(rho_2)*cos(rho_1)*cos(theta_2))*sin(theta_1) + omega_y*(sin(theta_1)*cos(rho_1)*cos(rho_2)*cos(theta_2) + sin(theta_2)*cos(theta_1)) - omega_z*(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1))*cos(theta_2)) - (omega_x*(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1))*sin(theta_1) + omega_y*(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2)) - omega_z*(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1))*sin(theta_2))*(-(sin(rho_1)*sin(theta_2) + sin(rho_2)*cos(rho_1)*cos(theta_2))*(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1))*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*sin(theta_2)*cos(theta_2) + (sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2))*(sin(theta_1)*cos(rho_1)*cos(rho_2)*cos(theta_2) + sin(theta_2)*cos(theta_1))))/pow(pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*pow(sin(theta_2), 2) + pow(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2), 2), 3.0/2.0);
   out_xxxxxxxxxxxxxxxxxxx[3] = ((pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*pow(sin(theta_2), 2) + pow(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2), 2))*(-omega_x*sin(theta_1)*cos(rho_1)*cos(rho_2) - omega_y*sin(rho_2)*sin(theta_1)*cos(rho_1) + omega_z*(sin(rho_1)*sin(rho_2)*sin(theta_1) + cos(rho_2)*cos(theta_1))) + (omega_x*(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1))*sin(theta_1) + omega_y*(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2)) - omega_z*(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1))*sin(theta_2))*((sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1))*pow(sin(theta_1), 2)*cos(rho_1)*cos(rho_2) + (sin(rho_1)*sin(rho_2)*sin(theta_1) + cos(rho_2)*cos(theta_1))*(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1))*sin(theta_2) + (sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2))*sin(rho_2)*sin(theta_1)*cos(rho_1)))*sin(theta_2)/pow(pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*pow(sin(theta_2), 2) + pow(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2), 2), 3.0/2.0);
}
/**
 * @brief Error derivatives of each parameter for a single measure. Spherical 1 and 2
 * 
 * @note Code generated by sympy
 * 
 * @param omega_x (input) X component of the relative angular velocity
 * @param omega_y (input) Y component of the relative angular velocity
 * @param omega_z (input) Z component of the relative angular velocity
 * @param theta_1 (input) Theta angle of the spherical representation of the first rotation vector
 * @param rho_1 (input) Rho angle of the spherical representation of the first rotation vector
 * @param theta_2 (input) Theta angle of the spherical representation of the second rotation vector
 * @param rho_2 (input) Rho angle of the spherical representation of the second rotation vector
 * @param out_xxxxxxxxxxxxxxxxxxx (output) Derivatives of the error according to each angle: de/dth1, de/drh1, de/dth2, de/drh2
 */
static void scal_error_derivatives_12(double omega_x, double omega_y, double omega_z, double theta_1, double rho_1, double theta_2, double rho_2, double *out_xxxxxxxxxxxxxxxxxxx) {
   out_xxxxxxxxxxxxxxxxxxx[0] = ((pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*pow(sin(theta_2), 2) + pow(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2), 2))*(omega_x*(sin(rho_1)*cos(rho_2)*cos(theta_1) + sin(rho_2)*sin(theta_1))*sin(theta_2) - omega_y*(sin(theta_1)*cos(theta_2) + sin(theta_2)*cos(rho_1)*cos(rho_2)*cos(theta_1)) - omega_z*(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1))*cos(theta_1)) + (-omega_x*(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1))*sin(theta_2) + omega_y*(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2)) + omega_z*(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1))*sin(theta_1))*(pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*sin(theta_1)*cos(theta_1) + (sin(theta_1)*cos(theta_2) + sin(theta_2)*cos(rho_1)*cos(rho_2)*cos(theta_1))*(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2)) + (sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1))*(sin(rho_1)*cos(rho_2)*cos(theta_1) + sin(rho_2)*sin(theta_1))*pow(sin(theta_2), 2)))/pow(pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*pow(sin(theta_2), 2) + pow(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2), 2), 3.0/2.0);
   out_xxxxxxxxxxxxxxxxxxx[1] = ((pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*pow(sin(theta_2), 2) + pow(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2), 2))*(omega_x*sin(theta_2)*cos(rho_1)*cos(rho_2) + omega_y*sin(rho_1)*sin(theta_2)*cos(rho_2) - omega_z*(sin(rho_1)*sin(rho_2)*sin(theta_2) + cos(rho_1)*cos(theta_2))) + (-omega_x*(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1))*sin(theta_2) + omega_y*(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2)) + omega_z*(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1))*sin(theta_1))*((sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1))*(sin(rho_1)*sin(rho_2)*sin(theta_2) + cos(rho_1)*cos(theta_2))*sin(theta_1) + (sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1))*pow(sin(theta_2), 2)*cos(rho_1)*cos(rho_2) - (sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2))*sin(rho_1)*sin(theta_2)*cos(rho_2)))*sin(theta_1)/pow(pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*pow(sin(theta_2), 2) + pow(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2), 2), 3.0/2.0);
   out_xxxxxxxxxxxxxxxxxxx[2] = ((pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*pow(sin(theta_2), 2) + pow(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2), 2))*(omega_x*(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1))*cos(theta_2) - omega_y*(sin(theta_1)*cos(rho_1)*cos(rho_2)*cos(theta_2) + sin(theta_2)*cos(theta_1)) + omega_z*(sin(rho_1)*sin(theta_2) + sin(rho_2)*cos(rho_1)*cos(theta_2))*sin(theta_1)) + (-omega_x*(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1))*sin(theta_2) + omega_y*(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2)) + omega_z*(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1))*sin(theta_1))*(-(sin(rho_1)*sin(theta_2) + sin(rho_2)*cos(rho_1)*cos(theta_2))*(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1))*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*sin(theta_2)*cos(theta_2) + (sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2))*(sin(theta_1)*cos(rho_1)*cos(rho_2)*cos(theta_2) + sin(theta_2)*cos(theta_1))))/pow(pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*pow(sin(theta_2), 2) + pow(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2), 2), 3.0/2.0);
   out_xxxxxxxxxxxxxxxxxxx[3] = ((-omega_x*(sin(rho_1)*sin(rho_2)*sin(theta_1) + cos(rho_2)*cos(theta_1)) + omega_y*sin(rho_2)*sin(theta_1)*cos(rho_1) + omega_z*sin(theta_1)*cos(rho_1)*cos(rho_2))*(pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*pow(sin(theta_2), 2) + pow(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2), 2)) - (-omega_x*(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1))*sin(theta_2) + omega_y*(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2)) + omega_z*(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1))*sin(theta_1))*((sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1))*pow(sin(theta_1), 2)*cos(rho_1)*cos(rho_2) + (sin(rho_1)*sin(rho_2)*sin(theta_1) + cos(rho_2)*cos(theta_1))*(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1))*sin(theta_2) + (sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2))*sin(rho_2)*sin(theta_1)*cos(rho_1)))*sin(theta_2)/pow(pow(sin(rho_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(rho_1), 2)*pow(sin(theta_1), 2) + pow(sin(rho_1)*sin(theta_1)*cos(rho_2) - sin(rho_2)*cos(theta_1), 2)*pow(sin(theta_2), 2) + pow(sin(theta_1)*sin(theta_2)*cos(rho_1)*cos(rho_2) - cos(theta_1)*cos(theta_2), 2), 3.0/2.0);
}
/**
 * @brief Error derivatives of each parameter for a single measure. Spherical 2 and 2
 * 
 * @note Code generated by sympy
 * 
 * @param omega_x (input) X component of the relative angular velocity
 * @param omega_y (input) Y component of the relative angular velocity
 * @param omega_z (input) Z component of the relative angular velocity
 * @param theta_1 (input) Theta angle of the spherical representation of the first rotation vector
 * @param rho_1 (input) Rho angle of the spherical representation of the first rotation vector
 * @param theta_2 (input) Theta angle of the spherical representation of the second rotation vector
 * @param rho_2 (input) Rho angle of the spherical representation of the second rotation vector
 * @param out_xxxxxxxxxxxxxxxxxxx (output) Derivatives of the error according to each angle: de/dth1, de/drh1, de/dth2, de/drh2
 */
static void scal_error_derivatives_22(double omega_x, double omega_y, double omega_z, double theta_1, double rho_1, double theta_2, double rho_2, double *out_xxxxxxxxxxxxxxxxxxx) {
   out_xxxxxxxxxxxxxxxxxxx[0] = (-1.0/32.0*(omega_x*sin(theta_1)*sin(theta_2)*sin(rho_1 - rho_2) + omega_y*(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1)) - omega_z*(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1)))*(4*sin(2*theta_1) + 6*sin(2*theta_1 - 2*theta_2) + 6*sin(2*theta_1 + 2*theta_2) - 2*sin(-2*rho_1 + 2*rho_2 + 2*theta_1) - 2*sin(2*rho_1 - 2*rho_2 + 2*theta_1) + sin(-2*rho_1 + 2*rho_2 + 2*theta_1 + 2*theta_2) - 4*sin(-rho_1 + rho_2 + 2*theta_1 + 2*theta_2) - 4*sin(rho_1 - rho_2 - 2*theta_1 + 2*theta_2) + 4*sin(rho_1 - rho_2 + 2*theta_1 - 2*theta_2) - 4*sin(rho_1 - rho_2 + 2*theta_1 + 2*theta_2) - sin(2*rho_1 - 2*rho_2 - 2*theta_1 + 2*theta_2) + sin(2*rho_1 - 2*rho_2 + 2*theta_1 - 2*theta_2) + sin(2*rho_1 - 2*rho_2 + 2*theta_1 + 2*theta_2)) + (omega_x*sin(theta_2)*sin(rho_1 - rho_2)*cos(theta_1) + omega_y*(sin(theta_1)*sin(theta_2)*cos(rho_2) + cos(rho_1)*cos(theta_1)*cos(theta_2)) - omega_z*(sin(rho_1)*cos(theta_1)*cos(theta_2) + sin(rho_2)*sin(theta_1)*sin(theta_2)))*(pow(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1), 2) + pow(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1), 2) + pow(sin(theta_1), 2)*pow(sin(theta_2), 2)*pow(sin(rho_1 - rho_2), 2)))/pow(pow(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1), 2) + pow(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1), 2) + pow(sin(theta_1), 2)*pow(sin(theta_2), 2)*pow(sin(rho_1 - rho_2), 2), 3.0/2.0);
   out_xxxxxxxxxxxxxxxxxxx[1] = (-(sin(theta_1)*sin(theta_2)*cos(rho_1 - rho_2) + cos(theta_1)*cos(theta_2))*(omega_x*sin(theta_1)*sin(theta_2)*sin(rho_1 - rho_2) + omega_y*(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1)) - omega_z*(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1)))*sin(theta_2)*sin(rho_1 - rho_2) + (omega_x*sin(theta_2)*cos(rho_1 - rho_2) - omega_y*sin(rho_1)*cos(theta_2) - omega_z*cos(rho_1)*cos(theta_2))*(pow(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1), 2) + pow(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1), 2) + pow(sin(theta_1), 2)*pow(sin(theta_2), 2)*pow(sin(rho_1 - rho_2), 2)))*sin(theta_1)/pow(pow(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1), 2) + pow(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1), 2) + pow(sin(theta_1), 2)*pow(sin(theta_2), 2)*pow(sin(rho_1 - rho_2), 2), 3.0/2.0);
   out_xxxxxxxxxxxxxxxxxxx[2] = ((1.0/32.0)*(omega_x*sin(theta_1)*sin(theta_2)*sin(rho_1 - rho_2) + omega_y*(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1)) - omega_z*(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1)))*(-4*sin(2*theta_2) + 6*sin(2*theta_1 - 2*theta_2) - 6*sin(2*theta_1 + 2*theta_2) + 2*sin(-2*rho_1 + 2*rho_2 + 2*theta_2) + 2*sin(2*rho_1 - 2*rho_2 + 2*theta_2) - sin(-2*rho_1 + 2*rho_2 + 2*theta_1 + 2*theta_2) + 4*sin(-rho_1 + rho_2 + 2*theta_1 + 2*theta_2) - 4*sin(rho_1 - rho_2 - 2*theta_1 + 2*theta_2) + 4*sin(rho_1 - rho_2 + 2*theta_1 - 2*theta_2) + 4*sin(rho_1 - rho_2 + 2*theta_1 + 2*theta_2) - sin(2*rho_1 - 2*rho_2 - 2*theta_1 + 2*theta_2) + sin(2*rho_1 - 2*rho_2 + 2*theta_1 - 2*theta_2) - sin(2*rho_1 - 2*rho_2 + 2*theta_1 + 2*theta_2)) + (omega_x*sin(theta_1)*sin(rho_1 - rho_2)*cos(theta_2) - omega_y*(sin(theta_1)*sin(theta_2)*cos(rho_1) + cos(rho_2)*cos(theta_1)*cos(theta_2)) + omega_z*(sin(rho_1)*sin(theta_1)*sin(theta_2) + sin(rho_2)*cos(theta_1)*cos(theta_2)))*(pow(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1), 2) + pow(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1), 2) + pow(sin(theta_1), 2)*pow(sin(theta_2), 2)*pow(sin(rho_1 - rho_2), 2)))/pow(pow(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1), 2) + pow(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1), 2) + pow(sin(theta_1), 2)*pow(sin(theta_2), 2)*pow(sin(rho_1 - rho_2), 2), 3.0/2.0);
   out_xxxxxxxxxxxxxxxxxxx[3] = ((sin(theta_1)*sin(theta_2)*cos(rho_1 - rho_2) + cos(theta_1)*cos(theta_2))*(omega_x*sin(theta_1)*sin(theta_2)*sin(rho_1 - rho_2) + omega_y*(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1)) - omega_z*(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1)))*sin(theta_1)*sin(rho_1 - rho_2) + (-omega_x*sin(theta_1)*cos(rho_1 - rho_2) + omega_y*sin(rho_2)*cos(theta_1) + omega_z*cos(rho_2)*cos(theta_1))*(pow(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1), 2) + pow(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1), 2) + pow(sin(theta_1), 2)*pow(sin(theta_2), 2)*pow(sin(rho_1 - rho_2), 2)))*sin(theta_2)/pow(pow(sin(rho_1)*sin(theta_1)*cos(theta_2) - sin(rho_2)*sin(theta_2)*cos(theta_1), 2) + pow(sin(theta_1)*cos(rho_1)*cos(theta_2) - sin(theta_2)*cos(rho_2)*cos(theta_1), 2) + pow(sin(theta_1), 2)*pow(sin(theta_2), 2)*pow(sin(rho_1 - rho_2), 2), 3.0/2.0);
}
/**
 * @brief Choose the required derivatives function
 * 
 * @param omega_x (input) X component of the relative angular velocity
 * @param omega_y (input) Y component of the relative angular velocity
 * @param omega_z (input) Z component of the relative angular velocity
 * @param theta_1 (input) Theta angle of the spherical representation of the first rotation vector
 * @param rho_1 (input) Rho angle of the spherical representation of the first rotation vector
 * @param theta_2 (input) Theta angle of the spherical representation of the second rotation vector
 * @param rho_2 (input) Rho angle of the spherical representation of the second rotation vector
 * @param out_xxxxxxxxxxxxxxxxxxx (output) Derivatives of the error according to each angle: de/dth1, de/drh1, de/dth2, de/drh2
 */
static void scal_error_derivatives(double omega_x, double omega_y, double omega_z, double theta_1, double rho_1, double theta_2, double rho_2, double *out_xxxxxxxxxxxxxxxxxxx) {
    int option = scal_data.sph_alt1 + (scal_data.sph_alt2 << 1);

    switch (option)
    {
    case 0+(0<<1):
        scal_error_derivatives_11(omega_x,omega_y,omega_z,theta_1,rho_1,theta_2,rho_2,out_xxxxxxxxxxxxxxxxxxx);
        break;
    case 1+(0<<1):
        scal_error_derivatives_21(omega_x,omega_y,omega_z,theta_1,rho_1,theta_2,rho_2,out_xxxxxxxxxxxxxxxxxxx);
        break;
    case 0+(1<<1):
        scal_error_derivatives_12(omega_x,omega_y,omega_z,theta_1,rho_1,theta_2,rho_2,out_xxxxxxxxxxxxxxxxxxx);
        break;
    case 1+(1<<1):
        scal_error_derivatives_22(omega_x,omega_y,omega_z,theta_1,rho_1,theta_2,rho_2,out_xxxxxxxxxxxxxxxxxxx);
        break;
    
    default:
        err_str("Invalid convination of spherical coordinate standars: 0x%x",option);
        break;
    }
}

/**
 * @brief Conversion from spherical coordinates to rotation vectors. Method 1
 * 
 * @note Code generated by sympy
 * 
 * @param theta_1 (input) Theta angle of the spherical representation of the rotation vector
 * @param rho_1 (input) Rho angle of the spherical representation of the rotation vector
 * @param out_xxxxxxxxxxxxxxxxxxx (output) Rotation vector obtained
 */
static void scal_spherical_2_vec_1(double theta_1, double rho_1, double *out_8227029826163990492) {
   out_8227029826163990492[0] = sin(theta_1)*cos(rho_1);
   out_8227029826163990492[1] = sin(rho_1)*sin(theta_1);
   out_8227029826163990492[2] = cos(theta_1);
}
/**
 * @brief Conversion from spherical coordinates to rotation vectors. Method 2
 * 
 * @note Code generated by sympy
 * 
 * @param theta_1 (input) Theta angle of the spherical representation of the rotation vector
 * @param rho_1 (input) Rho angle of the spherical representation of the rotation vector
 * @param out_xxxxxxxxxxxxxxxxxxx (output) Rotation vector obtained
 */
static void scal_spherical_2_vec_2(double theta_1, double rho_1, double *out_4420739202056071656) {
   out_4420739202056071656[0] = cos(theta_1);
   out_4420739202056071656[1] = sin(rho_1)*sin(theta_1);
   out_4420739202056071656[2] = sin(theta_1)*cos(rho_1);
}
/**
 * @brief Conversion from spherical coordinates to rotation vectors.
 * 
 * @param theta_1 (input) Theta angle of the spherical representation of the rotation vector
 * @param rho_1 (input) Rho angle of the spherical representation of the rotation vector
 * @param spherical_alt (input) spherical coordinates standard
 * @param out_xxxxxxxxxxxxxxxxxxx (output) Rotation vector obtained
 */
static void scal_spherical_2_vec(double theta_1, double rho_1, int spherical_alt, double *out_xxxxxxxxxxxxxxxxxxx) {
    switch (spherical_alt)
    {
    case 0:
        scal_spherical_2_vec_1(theta_1,rho_1,out_xxxxxxxxxxxxxxxxxxx);
        break;
    case 1:
        scal_spherical_2_vec_2(theta_1,rho_1,out_xxxxxxxxxxxxxxxxxxx);
        break;
    default:
        err_str("Invalid spherical coordinate standar: 0x%x",spherical_alt);
        break;
    }
}

/**
 * @brief Conversion from cartesian coordinates vector to spherical coordinates. Method 2
 * 
 * @note Code generated by sympy
 * 
 * @param x (input) X component of the cartesian vector
 * @param y (input) Y component of the cartesian vector
 * @param z (input) Z component of the cartesian vector
 * @param out_xxxxxxxxxxxxxxxxxxx (output) spherical coordinates: theta, rho
 */
void scal_spherical_1(double x, double y, double z, double *out_346291481195618932) {
   out_346291481195618932[0] = atan2(sqrt(pow(x, 2) + pow(y, 2)), z);
   out_346291481195618932[1] = atan2(y, x);
}
/**
 * @brief Conversion from cartesian coordinates vector to spherical coordinates. Method 2
 * 
 * @note Code generated by sympy
 * 
 * @param x (input) X component of the cartesian vector
 * @param y (input) Y component of the cartesian vector
 * @param z (input) Z component of the cartesian vector
 * @param out_xxxxxxxxxxxxxxxxxxx (output) spherical coordinates: theta, rho
 */
void scal_spherical_2(double x, double y, double z, double *out_2757485260694032718) {
   out_2757485260694032718[0] = atan2(sqrt(pow(y, 2) + pow(z, 2)), x);
   out_2757485260694032718[1] = atan2(y, z);
}
/**
 * @brief Conversion from cartesian coordinates vector to spherical coordinates
 * 
 * @param x (input) X component of the cartesian vector
 * @param y (input) Y component of the cartesian vector
 * @param z (input) Z component of the cartesian vector
 * @param spherical_alt (input/output) spherical coordinates standard
 * @param out_xxxxxxxxxxxxxxxxxxx (output) spherical coordinates: theta, rho
 */
static void scal_spherical(double x, double y, double z, int *spherical_alt, double *out_xxxxxxxxxxxxxxxxxxx) {
    switch (*spherical_alt)
    {
    case 0:
        scal_spherical_1(x,y,z,out_xxxxxxxxxxxxxxxxxxx);
        break;
    default:
        *spherical_alt = 1;
        scal_spherical_2(x,y,z,out_xxxxxxxxxxxxxxxxxxx);
        break;
    }
    if (0 && fabs(sin(out_xxxxxxxxxxxxxxxxxxx[0])) < 0.5 ) {
        wrn_str("Toggled spherical conversion");
        *spherical_alt ^= 1; // Toggle spherical standard
        scal_spherical(x,y,z,spherical_alt,out_xxxxxxxxxxxxxxxxxxx);
    }
}

ERROR_CODE cal_gn2_initialize(int imu_data_buff_size, int obs_data_buff_size) {
    ERROR_CODE status = RET_OK;

    // Initialize IMU measures buffer
    if (RET_OK == status) status = db_field_buffer_setup(DB_IMU_GYROSCOPE,0,imu_data_buff_size);
    if (RET_OK == status) status = db_field_buffer_setup(DB_IMU_GYROSCOPE,1,imu_data_buff_size);
    if (RET_OK == status) status = db_field_buffer_setup(DB_IMU_QUATERNION,0,imu_data_buff_size);
    if (RET_OK == status) status = db_field_buffer_setup(DB_IMU_QUATERNION,1,imu_data_buff_size);
    // Initialize observations buffer
    if (RET_OK == status) status = db_field_buffer_setup(DB_CALIB_OMEGA,0,obs_data_buff_size);
    // Set up parameters vector
    scal_data.phi = matrix_allocate(CAL_PARAMETERS_NUM,1);
    // Set initial error
    scal_data.error = 1e300;

    if (RET_OK == status) {
        log_str("Initialized calibration package");
        scal_data.initialized = true;
    }
    else {
        err_str("Failed to initialize calibration package");
    }

    return status;
}

void cal_gn2_terminate() {
    matrix_free(scal_data.phi);
    scal_data.initialized = false;
}

ERROR_CODE cal_gn2_observations_update(double omega1_from1[3], double omega2_from2[3], Quaternion q_sensor1, Quaternion q_sensor2) {
    ERROR_CODE status = RET_OK;
    Quaternion qR;
    double omega2_from1[3];
    double omegaR[3];

    // Check arguments
    if (NULL == omega1_from1)       return RET_ARG_ERROR;
    if (NULL == omega2_from2)       return RET_ARG_ERROR;

    // Compute relative quaternion
    qR = arm_quaternion_between_two_get(q_sensor1,q_sensor2);
    // Compute relative angular velocity
    Quaternion_rotate(&qR, omega2_from2, omega2_from1);
    status = vector3_substract(omega2_from1, omega1_from1, omegaR);

    // Update database
    double omegaR_norm;
    if (RET_OK == status) status = vector3_norm(omegaR, &omegaR_norm);
    if (RET_OK == status) status = db_write(DB_CALIB_OMEGA,0,omegaR);
    if (RET_OK == status) status = db_write(DB_CALIB_OMEGA_NORM, 0, &omegaR_norm);
    
    return status;
}

ERROR_CODE cal_gn2_observations_from_database_update() {
    ERROR_CODE status = RET_OK;
    double omega1_from1[3];
    double omega2_from2[3];
    double q_buff[4];
    Quaternion q_sensor1;
    Quaternion q_sensor2;

    int new_data_num = MIN(
        MIN(db_field_buffer_current_size_get(DB_IMU_GYROSCOPE,0),  db_field_buffer_current_size_get(DB_IMU_GYROSCOPE,1)),
        MIN(db_field_buffer_current_size_get(DB_IMU_QUATERNION,0), db_field_buffer_current_size_get(DB_IMU_QUATERNION,1))
    );
    
    for (int i = 0; RET_OK == status && i < new_data_num; i++) {
        // Retrieve IMUs data
        if (RET_OK == status) status = db_field_buffer_from_tail_data_get(DB_IMU_GYROSCOPE, 0,i,omega1_from1);
        if (RET_OK == status) status = db_field_buffer_from_tail_data_get(DB_IMU_GYROSCOPE, 1,i,omega2_from2);
        if (RET_OK == status) status = db_field_buffer_from_tail_data_get(DB_IMU_QUATERNION,0,i,q_buff);
        if (RET_OK == status) quaternion_from_buffer_build(q_buff, &q_sensor1);
        if (RET_OK == status) status = db_field_buffer_from_tail_data_get(DB_IMU_QUATERNION,1,i,q_buff);
        if (RET_OK == status) quaternion_from_buffer_build(q_buff, &q_sensor2);
        // Compute observations and log them into the database
        if (RET_OK == status) status = cal_gn2_observations_update(omega1_from1, omega2_from2, q_sensor1, q_sensor2);
    }
    if (RET_OK == status) {
        // Clear buffers
        if (RET_OK == status) status = db_field_buffer_clear(DB_IMU_GYROSCOPE,0);
        if (RET_OK == status) status = db_field_buffer_clear(DB_IMU_GYROSCOPE,1);
        if (RET_OK == status) status = db_field_buffer_clear(DB_IMU_QUATERNION,0);
        if (RET_OK == status) status = db_field_buffer_clear(DB_IMU_QUATERNION,1);
    }
    return status;
}

ERROR_CODE cal_gn2_root_mean_square(double rotationV1[3], double rotationV2[3], double *error) {
    ERROR_CODE status = RET_OK;
    int observations_num = db_field_buffer_current_size_get(DB_CALIB_OMEGA,0);  // Number of managed observations
    double obs_err;
    double sqr_err = 0.0;

    if (10 >= observations_num) {
        *error = 1e300;
        wrn_str("Insuficient observations to evaluate calibration error");
        return RET_NO_EXEC;
    }

    for (int i = 0; RET_OK == status && i < observations_num; i++) {
        double omegaR[3];
        // Retrieve omega R observation
        if (RET_OK == status) status = db_field_buffer_from_tail_data_get(DB_CALIB_OMEGA,0, i, omegaR);
        // Compute the error value
        if (RET_OK == status) obs_err = scal_error_xyz(
            rotationV1[0],rotationV1[1],rotationV1[2], 
            rotationV2[0],rotationV2[1],rotationV2[2], 
            omegaR[0],omegaR[1],omegaR[2]);
        // Acumulate squared error values
        if (RET_OK == status) sqr_err += obs_err*obs_err;
    }
    // Compute RMS
    if (RET_OK == status) *error = sqrt(sqr_err/observations_num);

    return status;
}

/**
 * @brief Make a single iteration of the Gauss-Newton algorithm
 * 
 * @param rotationV1 (input/output) First rotation vector
 * @param rotationV2 (input/output) Second rotation vector
 * @param error (output) Mean error of the new solution
 * @return ERROR_CODE 
 */
static ERROR_CODE scal_gn2_gauss_newton_iteration(double rotationV1[3], double rotationV2[3], double *error) {
    ERROR_CODE status = RET_OK;

    int observations_num = db_field_buffer_current_size_get(DB_CALIB_OMEGA,0);  // Number of managed observations
    if (0 >= observations_num) {
        wrn_str("No available observations for two axes calibration");
        return RET_NO_EXEC;
    }

    // Set spherical coordinates
    double sph[2];
    scal_spherical(rotationV1[0],rotationV1[1],rotationV1[2],&(scal_data.sph_alt1),sph);
    scal_data.phi.data[0][0] = sph[0];
    scal_data.phi.data[1][0] = sph[1];
    scal_spherical(rotationV2[0],rotationV2[1],rotationV2[2],&(scal_data.sph_alt2),sph);
    scal_data.phi.data[2][0] = sph[0];
    scal_data.phi.data[3][0] = sph[1];

    MATRIX errorV   = matrix_allocate(observations_num,1);  // Vector of residuals
    MATRIX Jacobian = matrix_allocate(observations_num,CAL_PARAMETERS_NUM);  // Jacobian matrix
    double obs_err;
    
    // Compute residuals vector and Jacobian
    double omegaR[3];
    for (int i = 0; RET_OK == status && i < observations_num; i++) {
        // Retrieve omega R observation
        if (RET_OK == status) status = db_field_buffer_from_tail_data_get(DB_CALIB_OMEGA,0, i, omegaR);
        // Compute the error value
        if (RET_OK == status) obs_err = scal_error_xyz(
            rotationV1[0],rotationV1[1],rotationV1[2], 
            rotationV2[0],rotationV2[1],rotationV2[2], 
            omegaR[0],omegaR[1],omegaR[2]);
        // Build residuals vector
        if (RET_OK == status) errorV.data[i][0] = obs_err;
        // Compute error derivatives and build Jacobian matrix
        if (RET_OK == status) scal_error_derivatives(
            omegaR[0],omegaR[1],omegaR[2], 
            scal_data.phi.data[0][0], scal_data.phi.data[1][0], scal_data.phi.data[2][0], scal_data.phi.data[3][0],
            Jacobian.data[i]);
    }

    // Apply Gauss-Newton algorithm to update Phi values
    if (RET_OK == status) {
        MATRIX Jpinv            = matrix_allocate(CAL_PARAMETERS_NUM,observations_num);  // Pseudoinverse of the Jacobian
        MATRIX phi_correction   = matrix_allocate(CAL_PARAMETERS_NUM,1);                 // Parameters delta

        if (RET_OK == status) status = matrix_pseudoinverse(Jacobian,&Jpinv);
        if (RET_OK == status) status = matrix_multiply(Jpinv, errorV, &phi_correction);
        if (RET_OK == status) status = matrix_substract(scal_data.phi, phi_correction, &scal_data.phi);

        matrix_free(Jpinv);
        matrix_free(phi_correction); 
    }
    matrix_free(errorV);
    matrix_free(Jacobian);

    // Compute total Root Mean Square value after correction
    if (RET_OK == status) status = cal_gn2_root_mean_square(rotationV1,rotationV2,error);

    // Set vectors with new parameters
    scal_spherical_2_vec(scal_data.phi.data[0][0], scal_data.phi.data[1][0], scal_data.sph_alt1, rotationV1);
    scal_spherical_2_vec(scal_data.phi.data[2][0], scal_data.phi.data[3][0], scal_data.sph_alt2, rotationV2);

    return status;
}

/**
 * @brief Generate a random number in a uniform distribution [-PI,PI]
 * 
 * @return double: The random value
 */
static double scal_rnd(){
    return 2*M_PI*((double)rand()/(double)RAND_MAX - 0.5);
}

static int totalIterations = 0;

ERROR_CODE cal_gn2_two_rot_axes_calib(double rotationV1[3], double rotationV2[3]) {
    ERROR_CODE status = RET_OK;

    double error; // Error value

    double initVector1[CAL_TRYS_NUM][3] = {
        {rotationV1[0],rotationV1[1],rotationV1[2]},
        {scal_rnd(),scal_rnd(),scal_rnd()},
        {scal_rnd(),scal_rnd(),scal_rnd()},
        {0,0,1},
        {0,0,1}
    };
    double initVector2[CAL_TRYS_NUM][3] = {
        {rotationV2[0],rotationV2[1],rotationV2[2]},
        {scal_rnd(),scal_rnd(),scal_rnd()},
        {scal_rnd(),scal_rnd(),scal_rnd()},
        {1,0,0},
        {0,1,0}
    };
    double tempV1[3],tempV2[3];

    // Get current error value
    status = cal_gn2_root_mean_square(rotationV1,rotationV2, &scal_data.error);
    
    for (int try = 0; RET_OK == status && try < CAL_TRYS_NUM; try++){
        if (RET_OK == status) status = vector3_copy(initVector1[try],tempV1);
        if (RET_OK == status) status = vector3_copy(initVector2[try],tempV2);
        for (int iteration = 0; RET_OK == status && CALIB_TWO_ROT_AXES_MAX_ITERATIONS > iteration; iteration++){
            // Execute one iteration of the gauss newton algorithm
            status = scal_gn2_gauss_newton_iteration(tempV1,tempV2, &error);
            // Use only the best set of rotation axes
            if (RET_OK == status && scal_data.error + EPSI > error) {
                scal_data.error = error;
                if (RET_OK == status) status = vector3_copy(tempV1,rotationV1);
                if (RET_OK == status) status = vector3_copy(tempV2,rotationV2);
            }

            dbg_str("%s -> [try: %d, it: %d] Current calib error: %.10f (best error: %.10f)",__FUNCTION__, 
                try, iteration, error, scal_data.error);

            // Log the error over the iterations when logging it into the CSV file
            if (db_csv_field_logging_check(DB_CALIB_ITERATIONS,0)) {
                // dbg_str("%s -> Logging calibration method iteration: %d",__FUNCTION__,totalIteration);
                if (RET_OK == status) totalIterations++;
                if (RET_OK == status) status = db_write(DB_CALIB_ITERATIONS,0,&totalIterations);
                if (RET_OK == status) status = db_write(DB_CALIB_ERROR, 0, &scal_data.error);
                if (RET_OK == status) status = db_csv_dump();
            }
        }
        if (RET_NO_EXEC == status) status = RET_OK;
    }
    
    // Update database
    if (RET_OK == status) {
        double spherical[] = {scal_data.phi.data[0][0], scal_data.phi.data[1][0], scal_data.sph_alt1};
        status = db_write(DB_CALIB_SPHERICAL_COORDS, 0, spherical);
    }
    if (RET_OK == status) {
        double spherical[] = {scal_data.phi.data[2][0], scal_data.phi.data[3][0], scal_data.sph_alt2};
        status = db_write(DB_CALIB_SPHERICAL_COORDS, 1, spherical);
    }
    if (RET_OK == status) {
        status = db_write(DB_CALIB_ERROR, 0, &scal_data.error);
    }
    if (RET_OK == status) {
        status = db_write(DB_CALIB_ROT_VECTOR, 0, rotationV1);
    }
    if (RET_OK == status) {
        status = db_write(DB_CALIB_ROT_VECTOR, 1, rotationV2);
    }

    return status;
}

ERROR_CODE cal_gn2_two_rot_axes_calib_correct(double rotationV1[3], double rotationV2[3]) {
    ERROR_CODE status = RET_OK;
    double tempV1[3],tempV2[3];
    double initV1[3],initV2[3];
    double error; // Error value
    bool improved = false;
    Quaternion q_correction;

    // Store starting rotation vectors
    if (RET_OK == status) status = vector3_copy(rotationV1,tempV1);
    if (RET_OK == status) status = vector3_copy(rotationV1,initV1);
    if (RET_OK == status) status = vector3_copy(rotationV2,tempV2);
    if (RET_OK == status) status = vector3_copy(rotationV2,initV2);

    // Get current error value
    if (RET_OK == status) status = cal_gn2_root_mean_square(rotationV1,rotationV2, &scal_data.error);

    for (int iteration = 0; RET_OK == status && CALIB_TWO_ROT_AXES_MAX_ITERATIONS/10 > iteration; iteration++){
        // Execute one iteration of the gauss newton algorithm
        status = scal_gn2_gauss_newton_iteration(tempV1,tempV2, &error);
        // Use only the best set of rotation axes
        if (RET_OK == status && scal_data.error + EPSI > error) {
            improved = true;
            scal_data.error = error;
            if (RET_OK == status) status = vector3_copy(tempV1,rotationV1);
            if (RET_OK == status) status = vector3_copy(tempV2,rotationV2);
        }

        dbg_str("%s -> [it: %d] Current calib error: %.10f (best error: %.10f)",__FUNCTION__, 
            iteration, error, scal_data.error);

        // Log the error over the iterations when logging it into the CSV file
        if (db_csv_field_logging_check(DB_CALIB_ITERATIONS,0)) {
            if (RET_OK == status) totalIterations++;
            if (RET_OK == status) status = db_write(DB_CALIB_ITERATIONS,0,&totalIterations);
            if (RET_OK == status) status = db_write(DB_CALIB_ERROR, 0, &scal_data.error);
            if (RET_OK == status) status = db_csv_dump();
        }
    }
    // Zero calibration data correct
    if (true == improved) {
        // Arm zeroing
        if (RET_OK == status) status = quaternion_between_two_vectors_compute(initV1,rotationV1,&q_correction);
        if (RET_OK == status) Quaternion_multiply(
            &scal_data.q_sensor_to_body_arm,&q_correction, &scal_data.q_sensor_to_body_arm);
        // Forearm zeroing
        if (RET_OK == status) status = quaternion_between_two_vectors_compute(initV2,rotationV2,&q_correction);
        if (RET_OK == status) Quaternion_multiply(
            &scal_data.q_sensor_to_body_forearm,&q_correction, &scal_data.q_sensor_to_body_forearm);
    }
    else {
        wrn_str("Could not improve current set of rotation vectors");
    }
    // Update database
    if (RET_OK == status) {
        double spherical[] = {scal_data.phi.data[0][0], scal_data.phi.data[1][0], scal_data.sph_alt1};
        status = db_write(DB_CALIB_SPHERICAL_COORDS, 0, spherical);
    }
    if (RET_OK == status) {
        double spherical[] = {scal_data.phi.data[2][0], scal_data.phi.data[3][0], scal_data.sph_alt2};
        status = db_write(DB_CALIB_SPHERICAL_COORDS, 1, spherical);
    }
    if (RET_OK == status) {
        status = db_write(DB_CALIB_ERROR, 0, &scal_data.error);
    }
    if (RET_OK == status) {
        status = db_write(DB_CALIB_ROT_VECTOR, 0, rotationV1);
    }
    if (RET_OK == status) {
        status = db_write(DB_CALIB_ROT_VECTOR, 1, rotationV2);
    }
    return status;
}

ERROR_CODE cal_gn2_zero_pose_calibrate(
    double rotationV1[3],
    double rotationV2[3], 
    Quaternion q_sensor1, 
    Quaternion q_sensor2,
    Quaternion q1_g_b_expected,
    Quaternion q2_g_b_expected,
    Quaternion *q1_zeroAndBody,
    Quaternion *q2_zeroAndBody)
{
    ERROR_CODE status = RET_OK;
    Quaternion q1_sp_g, q2_sp_g;
    Quaternion q1_zero, q2_zero;

    // Check arguments
    if (NULL == rotationV1) return RET_ARG_ERROR;
    if (NULL == rotationV2) return RET_ARG_ERROR;

    if (RET_OK == status) {
        // Invert global to sensor transform (IMU reading)
        Quaternion_conjugate(&q_sensor1, &q1_sp_g);
        Quaternion_conjugate(&q_sensor2, &q2_sp_g);
        // Compute the sensor to body transform  
        Quaternion_multiply(&q1_sp_g,&q1_g_b_expected, &q1_zero);
        Quaternion_multiply(&q2_sp_g,&q2_g_b_expected, &q2_zero);
    }

    if (RET_OK == status) {
        // Store transformation from raw sensors to zeroed body frames
        Quaternion_copy(&q1_zero, &scal_data.q_sensor_to_body_arm); 
        Quaternion_copy(&q2_zero, &scal_data.q_sensor_to_body_forearm);
        // Set output parameters
        if (NULL != q1_zeroAndBody) Quaternion_copy(&q1_zero,q1_zeroAndBody); 
        if (NULL != q2_zeroAndBody) Quaternion_copy(&q2_zero,q2_zeroAndBody); 

        log_str("Zeroing quats: arm:<%f, %f,%f,%f> forearm:<%f, %f,%f,%f>", 
            q1_zero.w, q1_zero.v[0], q1_zero.v[1], q1_zero.v[2], 
            q2_zero.w, q2_zero.v[0], q2_zero.v[1], q2_zero.v[2]);
    }

    // Set the zero for elbow angles
    if (RET_OK == status) status = arm_elbow_angles_zero(0.0, 0.0, q_sensor1, q_sensor2, rotationV1, rotationV2);

    return status;
}

ERROR_CODE cal_gn2_calibrated_orientations_from_database_get(Quaternion *q1, Quaternion *q2)
{
    ERROR_CODE status = RET_OK;
    double q_buff[4];
    Quaternion q1_toCalib,q2_toCalib;

    // Get the current quaternions 
    if (RET_OK == status) status = db_read(DB_IMU_QUATERNION,0,q_buff);
    if (RET_OK == status) quaternion_from_buffer_build(q_buff, &q1_toCalib);
    if (RET_OK == status) status = db_read(DB_IMU_QUATERNION,1,q_buff);
    if (RET_OK == status) quaternion_from_buffer_build(q_buff, &q2_toCalib);

    // Apply conversion to body global orientation
    if (RET_OK == status) {
        Quaternion_multiply(&scal_data.q_sensor_to_body_arm,     &q1_toCalib, q1);
        Quaternion_multiply(&scal_data.q_sensor_to_body_forearm, &q2_toCalib, q2);
    }

    dbg_str("%s -> \n\tRAW:   <%f, %f,%f,%f> ; <%f, %f,%f,%f> \n\tCALIB: <%f, %f,%f,%f> ; <%f, %f,%f,%f>",__FUNCTION__,
        q1_toCalib.w, q1_toCalib.v[0], q1_toCalib.v[1], q1_toCalib.v[2], 
        q2_toCalib.w, q2_toCalib.v[0], q2_toCalib.v[1], q2_toCalib.v[2], 
        q1->w, q1->v[0], q1->v[1], q1->v[2], 
        q2->w, q2->v[0], q2->v[1], q2->v[2]);

    return status;
}

ERROR_CODE cal_gn2_calibrated_relative_orientation_get(Quaternion *q, double angles[3]) {
    ERROR_CODE status = RET_OK;
    Quaternion q1, q2;
    Quaternion qR;
    double anglesPS_B_FE[3];

    if (NULL == q && NULL == angles) return RET_ARG_ERROR;

    status = cal_gn2_calibrated_orientations_from_database_get(&q1,&q2);
    if (RET_OK == status) {
        qR = arm_quaternion_between_two_get(q2,q1);
        Quaternion_toEulerZYX(&qR,anglesPS_B_FE); // [PS,CARRYING,FE]
    }
    // Update database
    if (RET_OK == status) {
        double q_buff[4] = {qR.w,qR.v[0],qR.v[1],qR.v[2]};
        status = db_write(DB_ARM_ELBOW_QUATERNION,0,q_buff);
    }
    if (RET_OK == status) status = db_write(DB_ARM_ELBOW_ANGLES,0,anglesPS_B_FE);
    // Set output
    if (RET_OK == status && NULL != q) Quaternion_copy(&qR,q);
    if (RET_OK == status && NULL != angles) status = vector3_copy(anglesPS_B_FE,angles);

    return status;
}
